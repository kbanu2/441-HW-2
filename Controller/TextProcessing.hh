// This file is generated by omniidl (C++ backend)- omniORB_4_3. Do not edit.
#ifndef __TextProcessing_hh__
#define __TextProcessing_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_TextProcessing
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_TextProcessing
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_TextProcessing
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE TextProcessing

_CORBA_MODULE_BEG

  class StringList_var;

  class StringList : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef StringList_var _var_type;
    inline StringList() {}
    inline StringList(const StringList& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline StringList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline StringList(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline StringList& operator = (const StringList& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class StringList_out;

  class StringList_var {
  public:
    inline StringList_var() : _pd_seq(0) {}
    inline StringList_var(StringList* _s) : _pd_seq(_s) {}
    inline StringList_var(const StringList_var& _s) {
      if (_s._pd_seq)  _pd_seq = new StringList(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~StringList_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline StringList_var& operator = (StringList* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline StringList_var& operator = (const StringList_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new StringList;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline StringList* operator -> () { return _pd_seq; }
    inline const StringList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator StringList& () const { return *_pd_seq; }
#else
    inline operator const StringList& () const { return *_pd_seq; }
    inline operator StringList& () { return *_pd_seq; }
#endif
      
    inline const StringList& in() const { return *_pd_seq; }
    inline StringList&       inout()    { return *_pd_seq; }
    inline StringList*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline StringList* _retn() { StringList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class StringList_out;
    
  private:
    StringList* _pd_seq;
  };

  class StringList_out {
  public:
    inline StringList_out(StringList*& _s) : _data(_s) { _data = 0; }
    inline StringList_out(StringList_var& _s)
      : _data(_s._pd_seq) { _s = (StringList*) 0; }
    inline StringList_out(const StringList_out& _s) : _data(_s._data) {}
    inline StringList_out& operator = (const StringList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline StringList_out& operator = (StringList* _s) {
      _data = _s;
      return *this;
    }
    inline operator StringList*&()  { return _data; }
    inline StringList*& ptr()       { return _data; }
    inline StringList* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    StringList*& _data;

  private:
    StringList_out();
    StringList_out& operator=(const StringList_var&);
  };

  class DoubleList_var;

  class DoubleList : public _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 >  {
  public:
    typedef DoubleList_var _var_type;
    inline DoubleList() {}
    inline DoubleList(const DoubleList& _s)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_s) {}

    inline DoubleList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max) {}
    inline DoubleList(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Double* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > (_max, _len, _val, _rel) {}

  

    inline DoubleList& operator = (const DoubleList& _s) {
      _CORBA_Unbounded_Sequence_w_FixSizeElement< ::CORBA::Double, 8, 8 > ::operator=(_s);
      return *this;
    }
  };

  class DoubleList_out;

  class DoubleList_var {
  public:
    inline DoubleList_var() : _pd_seq(0) {}
    inline DoubleList_var(DoubleList* _s) : _pd_seq(_s) {}
    inline DoubleList_var(const DoubleList_var& _s) {
      if (_s._pd_seq)  _pd_seq = new DoubleList(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~DoubleList_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline DoubleList_var& operator = (DoubleList* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline DoubleList_var& operator = (const DoubleList_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new DoubleList;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline ::CORBA::Double& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline DoubleList* operator -> () { return _pd_seq; }
    inline const DoubleList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator DoubleList& () const { return *_pd_seq; }
#else
    inline operator const DoubleList& () const { return *_pd_seq; }
    inline operator DoubleList& () { return *_pd_seq; }
#endif
      
    inline const DoubleList& in() const { return *_pd_seq; }
    inline DoubleList&       inout()    { return *_pd_seq; }
    inline DoubleList*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline DoubleList* _retn() { DoubleList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class DoubleList_out;
    
  private:
    DoubleList* _pd_seq;
  };

  class DoubleList_out {
  public:
    inline DoubleList_out(DoubleList*& _s) : _data(_s) { _data = 0; }
    inline DoubleList_out(DoubleList_var& _s)
      : _data(_s._pd_seq) { _s = (DoubleList*) 0; }
    inline DoubleList_out(const DoubleList_out& _s) : _data(_s._data) {}
    inline DoubleList_out& operator = (const DoubleList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline DoubleList_out& operator = (DoubleList* _s) {
      _data = _s;
      return *this;
    }
    inline operator DoubleList*&()  { return _data; }
    inline DoubleList*& ptr()       { return _data; }
    inline DoubleList* operator->() { return _data; }

    inline ::CORBA::Double& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    DoubleList*& _data;

  private:
    DoubleList_out();
    DoubleList_out& operator=(const DoubleList_var&);
  };

  struct WordFrequency {
    typedef _CORBA_ConstrType_Variable_Var<WordFrequency> _var_type;

    
    ::CORBA::String_member word;

    ::CORBA::Long frequency;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef WordFrequency::_var_type WordFrequency_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< WordFrequency,WordFrequency_var > WordFrequency_out;

  struct WordMap {
    typedef _CORBA_ConstrType_Variable_Var<WordMap> _var_type;

    
    ::CORBA::String_member word;

    ::CORBA::Long uid;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef WordMap::_var_type WordMap_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< WordMap,WordMap_var > WordMap_out;

  class WordFrequencyList_var;

  class WordFrequencyList : public _CORBA_Unbounded_Sequence< WordFrequency >  {
  public:
    typedef WordFrequencyList_var _var_type;
    inline WordFrequencyList() {}
    inline WordFrequencyList(const WordFrequencyList& _s)
      : _CORBA_Unbounded_Sequence< WordFrequency > (_s) {}

    inline WordFrequencyList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< WordFrequency > (_max) {}
    inline WordFrequencyList(_CORBA_ULong _max, _CORBA_ULong _len, WordFrequency* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< WordFrequency > (_max, _len, _val, _rel) {}

  

    inline WordFrequencyList& operator = (const WordFrequencyList& _s) {
      _CORBA_Unbounded_Sequence< WordFrequency > ::operator=(_s);
      return *this;
    }
  };

  class WordFrequencyList_out;

  class WordFrequencyList_var {
  public:
    inline WordFrequencyList_var() : _pd_seq(0) {}
    inline WordFrequencyList_var(WordFrequencyList* _s) : _pd_seq(_s) {}
    inline WordFrequencyList_var(const WordFrequencyList_var& _s) {
      if (_s._pd_seq)  _pd_seq = new WordFrequencyList(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~WordFrequencyList_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline WordFrequencyList_var& operator = (WordFrequencyList* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline WordFrequencyList_var& operator = (const WordFrequencyList_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new WordFrequencyList;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline WordFrequency& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline WordFrequencyList* operator -> () { return _pd_seq; }
    inline const WordFrequencyList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator WordFrequencyList& () const { return *_pd_seq; }
#else
    inline operator const WordFrequencyList& () const { return *_pd_seq; }
    inline operator WordFrequencyList& () { return *_pd_seq; }
#endif
      
    inline const WordFrequencyList& in() const { return *_pd_seq; }
    inline WordFrequencyList&       inout()    { return *_pd_seq; }
    inline WordFrequencyList*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline WordFrequencyList* _retn() { WordFrequencyList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class WordFrequencyList_out;
    
  private:
    WordFrequencyList* _pd_seq;
  };

  class WordFrequencyList_out {
  public:
    inline WordFrequencyList_out(WordFrequencyList*& _s) : _data(_s) { _data = 0; }
    inline WordFrequencyList_out(WordFrequencyList_var& _s)
      : _data(_s._pd_seq) { _s = (WordFrequencyList*) 0; }
    inline WordFrequencyList_out(const WordFrequencyList_out& _s) : _data(_s._data) {}
    inline WordFrequencyList_out& operator = (const WordFrequencyList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline WordFrequencyList_out& operator = (WordFrequencyList* _s) {
      _data = _s;
      return *this;
    }
    inline operator WordFrequencyList*&()  { return _data; }
    inline WordFrequencyList*& ptr()       { return _data; }
    inline WordFrequencyList* operator->() { return _data; }

    inline WordFrequency& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    WordFrequencyList*& _data;

  private:
    WordFrequencyList_out();
    WordFrequencyList_out& operator=(const WordFrequencyList_var&);
  };

  class WordMapList_var;

  class WordMapList : public _CORBA_Unbounded_Sequence< WordMap >  {
  public:
    typedef WordMapList_var _var_type;
    inline WordMapList() {}
    inline WordMapList(const WordMapList& _s)
      : _CORBA_Unbounded_Sequence< WordMap > (_s) {}

    inline WordMapList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< WordMap > (_max) {}
    inline WordMapList(_CORBA_ULong _max, _CORBA_ULong _len, WordMap* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< WordMap > (_max, _len, _val, _rel) {}

  

    inline WordMapList& operator = (const WordMapList& _s) {
      _CORBA_Unbounded_Sequence< WordMap > ::operator=(_s);
      return *this;
    }
  };

  class WordMapList_out;

  class WordMapList_var {
  public:
    inline WordMapList_var() : _pd_seq(0) {}
    inline WordMapList_var(WordMapList* _s) : _pd_seq(_s) {}
    inline WordMapList_var(const WordMapList_var& _s) {
      if (_s._pd_seq)  _pd_seq = new WordMapList(*_s._pd_seq);
      else             _pd_seq = 0;
    }
    inline ~WordMapList_var() { if (_pd_seq)  delete _pd_seq; }
      
    inline WordMapList_var& operator = (WordMapList* _s) {
      if (_pd_seq)  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline WordMapList_var& operator = (const WordMapList_var& _s) {
      if (&_s != this) {
        if (_s._pd_seq) {
          if (!_pd_seq)  _pd_seq = new WordMapList;
          *_pd_seq = *_s._pd_seq;
        }
        else if (_pd_seq) {
          delete _pd_seq;
          _pd_seq = 0;
        }
      }
      return *this;
    }
    inline WordMap& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline WordMapList* operator -> () { return _pd_seq; }
    inline const WordMapList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator WordMapList& () const { return *_pd_seq; }
#else
    inline operator const WordMapList& () const { return *_pd_seq; }
    inline operator WordMapList& () { return *_pd_seq; }
#endif
      
    inline const WordMapList& in() const { return *_pd_seq; }
    inline WordMapList&       inout()    { return *_pd_seq; }
    inline WordMapList*&      out() {
      if (_pd_seq) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline WordMapList* _retn() { WordMapList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class WordMapList_out;
    
  private:
    WordMapList* _pd_seq;
  };

  class WordMapList_out {
  public:
    inline WordMapList_out(WordMapList*& _s) : _data(_s) { _data = 0; }
    inline WordMapList_out(WordMapList_var& _s)
      : _data(_s._pd_seq) { _s = (WordMapList*) 0; }
    inline WordMapList_out(const WordMapList_out& _s) : _data(_s._data) {}
    inline WordMapList_out& operator = (const WordMapList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline WordMapList_out& operator = (WordMapList* _s) {
      _data = _s;
      return *this;
    }
    inline operator WordMapList*&()  { return _data; }
    inline WordMapList*& ptr()       { return _data; }
    inline WordMapList* operator->() { return _data; }

    inline WordMap& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    WordMapList*& _data;

  private:
    WordMapList_out();
    WordMapList_out& operator=(const WordMapList_var&);
  };

  struct ProcessingResult {
    typedef _CORBA_ConstrType_Variable_Var<ProcessingResult> _var_type;

    
    WordFrequencyList wordFrequencies;

    WordMapList wordMappings;

    typedef _CORBA_Unbounded_Sequence< DoubleList >  _vectorEmbedding_seq;
    _vectorEmbedding_seq vectorEmbedding;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ProcessingResult::_var_type ProcessingResult_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ProcessingResult,ProcessingResult_var > ProcessingResult_out;

#ifndef __TextProcessing_mFileProcessor__
#define __TextProcessing_mFileProcessor__
  class FileProcessor;
  class _objref_FileProcessor;
  class _impl_FileProcessor;
  
  typedef _objref_FileProcessor* FileProcessor_ptr;
  typedef FileProcessor_ptr FileProcessorRef;

  class FileProcessor_Helper {
  public:
    typedef FileProcessor_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_FileProcessor, FileProcessor_Helper> FileProcessor_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_FileProcessor,FileProcessor_Helper > FileProcessor_out;

#endif

  // interface FileProcessor
  class FileProcessor {
  public:
    // Declarations for this interface type.
    typedef FileProcessor_ptr _ptr_type;
    typedef FileProcessor_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_FileProcessor :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    ProcessingResult* processChunk(const char* chunkContent);
    void writeResults(const ::TextProcessing::ProcessingResult& results);

    // Constructors
    inline _objref_FileProcessor()  { _PR_setobj(0); }  // nil
    _objref_FileProcessor(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_FileProcessor();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_FileProcessor(const _objref_FileProcessor&);
    _objref_FileProcessor& operator = (const _objref_FileProcessor&);
    // not implemented

    friend class FileProcessor;
  };

  class _pof_FileProcessor : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_FileProcessor() : _OMNI_NS(proxyObjectFactory)(FileProcessor::_PD_repoId) {}
    virtual ~_pof_FileProcessor();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_FileProcessor :
    public virtual omniServant
  {
  public:
    virtual ~_impl_FileProcessor();

    virtual ProcessingResult* processChunk(const char* chunkContent) = 0;
    virtual void writeResults(const ::TextProcessing::ProcessingResult& results) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


#ifndef __TextProcessing_mController__
#define __TextProcessing_mController__
  class Controller;
  class _objref_Controller;
  class _impl_Controller;
  
  typedef _objref_Controller* Controller_ptr;
  typedef Controller_ptr ControllerRef;

  class Controller_Helper {
  public:
    typedef Controller_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_Controller, Controller_Helper> Controller_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_Controller,Controller_Helper > Controller_out;

#endif

  // interface Controller
  class Controller {
  public:
    // Declarations for this interface type.
    typedef Controller_ptr _ptr_type;
    typedef Controller_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static inline _ptr_type _fromObjRef(omniObjRef* o) {
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_Controller :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    // IDL operations
    void startProcessing(const char* filename);
    void finishProcessing();

    // Constructors
    inline _objref_Controller()  { _PR_setobj(0); }  // nil
    _objref_Controller(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_Controller();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_Controller(const _objref_Controller&);
    _objref_Controller& operator = (const _objref_Controller&);
    // not implemented

    friend class Controller;
  };

  class _pof_Controller : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_Controller() : _OMNI_NS(proxyObjectFactory)(Controller::_PD_repoId) {}
    virtual ~_pof_Controller();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_Controller :
    public virtual omniServant
  {
  public:
    virtual ~_impl_Controller();

    virtual void startProcessing(const char* filename) = 0;
    virtual void finishProcessing() = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_TextProcessing
_CORBA_MODULE_BEG

  class FileProcessor :
    public virtual TextProcessing::_impl_FileProcessor,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~FileProcessor();

    inline ::TextProcessing::FileProcessor_ptr _this() {
      return (::TextProcessing::FileProcessor_ptr) _do_this(::TextProcessing::FileProcessor::_PD_repoId);
    }
  };

  class Controller :
    public virtual TextProcessing::_impl_Controller,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~Controller();

    inline ::TextProcessing::Controller_ptr _this() {
      return (::TextProcessing::Controller_ptr) _do_this(::TextProcessing::Controller::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_TextProcessing
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
TextProcessing::FileProcessor::_marshalObjRef(::TextProcessing::FileProcessor_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
TextProcessing::Controller::_marshalObjRef(::TextProcessing::Controller_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_TextProcessing
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_TextProcessing
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_TextProcessing
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_TextProcessing
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_TextProcessing
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_TextProcessing
#endif

#endif  // __TextProcessing_hh__

